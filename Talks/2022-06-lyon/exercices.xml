<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>Un peu de XPath, un peu de XSLT</title>
        <author>Lou Burnard</author>
        <author>Alexei Lavrentev</author>
      </titleStmt>
      <editionStmt>
        <edition>
          <date when="2022-06">juin 2022</date>
        </edition>
      </editionStmt>
      <publicationStmt>
        <p/>
      </publicationStmt>
      <sourceDesc>
        <p>Avec des notions prises dans le TP-5 de Florence. </p>
      </sourceDesc>
    </fileDesc>
    <encodingDesc>
      <projectDesc>
        <p>Texte préparé pour le stage "XSLT pour les nuls" MUTEC le 26 mai 2011. Révisé pour l'EThap juin 2022</p>
      </projectDesc>
    </encodingDesc>
    <revisionDesc>
      <change when="2011-05-23">Drafted on train</change>
      <change when="2017-10-18">Updates and adapted for 2017 TEI training in Tours</change>
    </revisionDesc>
  </teiHeader>
  <text>
    <body>
      <div>
        <head>Exercice XPath et XSLT</head>
        <figure>
        <graphic url="../Graphics/duBellay.png" height="10cm"/>
      </figure>
      <p>Dans ce petit exercice et le suivant, on prend comme exemple une version numérisée d’un
        célèbre sonnet de DuBellay. Vous trouverez une version de ce sonnet déjà balisée dans le
        fichier <ident>duBellay.xml</ident> — ouvrez-le d’abord avec Oxygen.</p></div>
      <div>
        <head>XPath</head>
        <div>
          <head>Navigation avec XPath</head>
          <p>oXygen est très pratique pour voir un peu ce que l’utilisation de XPath seul peut
            apporter à un processus d’exploration, d’appropriation ou de vérification de document
            TEI. La ligne de saisie "XPath" que l’on voit a gauche en haut de la fenêtre, au-dessous
            des barres d’outils oXygen, permet de saisir des expressions XPath. Après avoir tapé sur
            la touche <ident>Entrée</ident> au clavier, oXygen évalue l’expression et retourne, dans
            la fenêtre qui fait toute la largeur de l’écran en bas, une liste de(s) résultat(s) – un
            ou plusieurs ensembles de nœuds, en donnant pour chaque nœud résultat l’expression XPath
            qui permet de l’atteindre. Si on clique avec la souris sur une des lignes de résultat,
            oXygen montre le nœud résultat sélectionné dans son contexte TEI au sein de la fenêtre
            de l’éditeur.</p>
          <!--p><graphic url="XPath-tool.jpg" height="200px"/></p-->
          <p>Voici une petite liste de requêtes que vous devriez essayer d’exprimer au moyen du
            langage XPath : <list type="ordered">
              <item>quel est l’élément racine du document XML ?</item>
              <item>quel est le titre donné à ce document ?</item>
              <item>qui est le responsable de la création du fichier ?</item>
              <item>quelle est l’origine de la version encodée ?</item>
              <item>quelle est la date de la révision la plus récente du document ?</item>
              <item>combien y a-t-il de strophes (<gi>lg</gi>) dans le sonnet ?</item>
              <item>combien y a-t-il de segments de texte dont la graphie est considérée incorrecte
                  (<gi>orig</gi>) aujourd’hui ?</item>
              <item>combien y a-t-il de vers (<gi>l</gi>) qui contiennent au moins un tel
                segment ?</item>
              <item>quel est le contenu textuel du premier vers de chaque strophe ? et du dernier? </item>
              <item>Quels nœuds texte contiennent la chaîne de caractères "jamais"</item>
            </list></p>
          <p>On va faire ces exercices ensemble. Des réponses sont proposées dans la section qui
            suit : ne les regardez pas si vous préférez tester vos compétences !</p>
  <!--        <p>Nota : on utilise ici XPath 2.0 (à cause de l’espace de noms par défaut).</p>
 -->       </div>

        <div>

          <head> Exercice XPath corrigé</head>

          <list type="gloss">
            <label>Quel est l’élément racine du document XML ?</label>
            <item>
              <p>Expression XPath à écrire : </p>
              <p><code>/*</code> [le nœud document est désigné par le slash ; la 2<hi
                  rend="superscript">e</hi> étape désigne les enfants de type élément de ce
                nœud]</p>
              <p>Réponse : TEI </p>
            </item>
            <label>Quel est le titre donné au document ?</label>
            <item>
              <p>Expression XPath à écrire : </p>
              <p><code>/TEI/teiHeader/fileDesc/titleStmt/title</code> ou encore (entre autres
                possibilités) : <code>//titleStmt/title</code></p>
              <p>Réponse : On voit les trois nœuds <gi>title</gi> qui répondent à la question. Si on
                voulait obtenir le titre proprement dit (sans le complément de titre), il faudrait
                connaître précisément le modèle auquel obéit ce document, et demander le nœud
                  <gi>title</gi> en première position (//titleStmt/title[1]), ou de choisir le nœud
                  <gi>title</gi> dont l’attribut <att>type</att> porte une valeur appropriée
                  (<code>//titleStmt/title[@type=’main’)]</code>). </p>
            </item>
            <label>Qui est responsable de la création et de l'édition du fichier ?</label>
            <item>
              <p>Expression XPath à écrire : </p>
              <p><code> //titleStmt/respStmt/name</code></p>
              <p>Réponse : 2 nœuds ici.</p>
            </item>
            <label>Quelle est l’origine de la version encodée ?</label>
            <item>
              <p>Expression XPath à écrire : </p>
              <p><code>//sourceDesc/*</code> ou, plus finement,
                  <code>/TEI/fileDesc/sourceDesc/*</code>. Sans le <code>*</code> vous ne recevrez
                que l’élément de groupement <gi>sourceDesc</gi>, sans ses composants.</p>
            </item>
            <label>Quelle est la date de la révision la plus récente du document ?</label>
            <item>
              <p>Expression XPath à écrire :</p>
              <p>
                <code>revisionDesc/change[1]/@when</code>. Par défaut, le premier <gi>change</gi>
                devrait être le plus récent, et son attribut <att>when</att> donnera sa date dans un
                format normalisé.</p>
              <p>Réponse : 2017-10-18 </p>
            </item>
            <label>Combien y a-t-il de strophes (<gi>lg</gi>) dans le sonnet ? </label>
            <item>
              <p>Expression XPath à écrire : </p>
              <p><code>count(//lg)</code>. On se sert de la fonction <code>count()</code>.</p>
              <p>Réponse : 4 </p>
            </item>
            <label>Combien y a-t-il de <gi>orig</gi>, i.e. des segments de texte dont la graphie est
              consideré incorrecte aujourd’hui ?</label>
            <item>
              <p>Expression XPath à écrire : </p>
              <p>
                <code>count(/TEI/text//orig)</code>. Enlevez le <code>count()</code> si vous
                préfériez les voir…</p>
              <p>Réponse : 18</p>
            </item>
            <label>Combien y a-t-il de vers (<gi>l</gi>) qui contient au moins un tel
              segment?</label>
            <item>
              <p>Expression XPath à écrire : </p>
              <p><code>count(//l[descendant::orig])</code></p>
              <p>Réponse : 7</p>
            </item>
            <label>Et combien y a-t-il de <gi>orig</gi> qui sont contenu directement par un
                <gi>l</gi> ?</label>
            <item>
              <p>Expression XPath à écrire : </p>
              <p><code>count(//l/orig)</code></p>
              <p>Réponse : 3</p>
            </item>
            <label>Quel est le contenu textuel du premier vers de chaque strophe ? et du
              dernier ?</label>
            <item>
              <p>Expression XPath à écrire :</p>
              <p>
                <code>//lg/l[1]//text()</code></p>
              <p>Pour le dernier, c’est un peu moins evident…
                  <code>//lg/l[position()=last()]//text()</code>
              </p>
            </item>
            <label>Quels nœuds texte contiennent la chaîne de caractères "jamais" ? et quels vers?</label>
            <item>
              <p>Expression XPath à écrire : </p>
              <p><code>//text()[contains(., ’avare’)]</code></p>
              <p><code>//l[contains(., ’avare’)]</code></p>
              <p>Réponse : la premiere liste de réponses contient 2 nœuds; la deuxieme qu'un.</p>
            </item>
          </list>
        </div>

      </div>

      <div>
        <head>XSLT</head>

        <p>Dans ce deuxième petit exercice, nous allons faire des expériences avec XSLT sous
          contrôle d’oXygen. On va travailler avec cette version du même sonnet de DuBellay qui a
          été (partiellement) enrichie avec des balises <gi>choice</gi>. </p>
        <div>
          <head>Transformation en HTML</head>

          <p>L’application classique de XSLT est de transformer un document TEI XML en HTML pour le
            visualiser dans un navigateur web. On commence donc par là. </p>
          <p>Pour faire cela, il faut mettre en place une liaison entre le fichier XML d’entrée, le fichier
            HTML de sortie, et le fichier XSLT qui va contrôler la transformation. Il y a une méthode plus élaborée pour créer ce qu'on appelle un <term>scénario de transformation</term>, mais pour l'instant nous allons effectuer cette liaison de la manière la plus simple.
          </p>
          <list type="ordered">
            <item> Ouvrez Oxygen. Sélectionnez <ident>Ouvrir</ident> sur le menu
                <ident>Fichier</ident> et ouvrez le fichier <ident>duBellay.xml</ident>.</item>
            <item>Sur le menu <ident>Document</ident> sélectionnez <ident>XML Document</ident>, et
              ensuite <ident>Associate XSLT/CSS Stylesheet</ident> ou cliquez le bouton avec un épingle bleu sur la barre d'outils</item>
            <item>Dans le dialog qui s'affiche, assurez vous d'ouvrir l'onglet XSLT. Puis
              tapez <code>duBellay.xsl</code> dans le champ <ident>XSL URL</ident>.</item><item>Votre document <ident>duBellay.xml</ident> est maintenant doté d'une <term>processing instruction</term>
                   <code>&lt;?xml-stylesheet type="text/xsl" href="duBellay.xsl"?</code></item>
             <!-- <item>Sur le menu <ident>Document</ident> sélectionnez <ident>Transformation</ident>, et
              ensuite <ident>Configurer un scénario de transformation</ident> ou tapez
                <code>ctrl-maj-C</code>, ou bien cliquez sur le bouton à droite du triangle rouge
              sur la barre d’outils.</item>
          </list>
          <p>Cliquez d’abord sur <ident>nouveau</ident> pour ouvrir la boîte de dialogue
              <ident>Nouveau Scénario</ident>.</p>
          <p><graphic height="5cm" url="../images/scenario-2.png"/></p>
          <list>
            <item>Tapez <code>duBellay.xsl</code> dans le champ <ident>XSL URL</ident>.</item>
            <item>Selectionnez <ident>Saxon HE 9.X</ident> dans le menu déroulant labellisé
                <ident>Transformateur</ident> (le version de Saxon peut varier selon la version d'oXygen)</item>
            <item>Cliquez sur l’onglet <code>Sortie</code>
            </item>
            <item>Cliquez sur l'icône « flèche verte sur trois petits points » à droite du champ <code>Enregistrer sous</code>
            </item>
            <item>Sélectionnez la variable <code>${cfn}</code>, puis tapez <code>.html</code> juste après <code>${cfn}</code> dans le champ</item>
            <item>Cochez la case <code>Ouvrir dans un navigateur</code></item>
            <item>Cliquez sur <code>Accepter</code></item>
          </list>
          <p>Vous avez maintenant créé un nouveau scénario de transformation, qui s’appelle
              <ident>duBellay</ident>.</p>
          <p>
           <graphic height="5cm" url="../images/scenario-4.png"/></p>
          <list>--> 
          <item>  Sur le menu <ident>Document</ident> sélectionnez <ident>Transformation</ident>, et
            ensuite <ident>Apply Transformation Scenario</ident> ou tapez
            <code>ctrl-maj-T</code>, ou bien cliquez sur le bouton avec un grand triangle rouge
            sur la barre d’outils.</item>
             <item>En bas de l’écran, le message <code>Transformation réussie</code> apparaît… </item>
            <item>.. et après un bref délai, votre navigateur devrait s’ouvrir pour afficher le
              fichier <ident>duBellay.html</ident> que vous venez de créer.</item>
            <item>C’est joli, hein ? Peut-être y a-t-il encore un peu de travail à faire…</item>
          </list>

        </div>

        <div>
          <head>Une feuille de style XSLT</head>
          <p>Une feuille de style XSLT est un document XML comme les autres. Il peut donc être édité avec Oxygen. <list>
              <item>Allez de nouveau sur <ident>Fichier - Ouvrir</ident>. Ouvrez le fichier
                  <ident>duBellay.xsl</ident> dans votre dossier de travail.</item>
              <item>Ce fichier XSLT contient un seul template, qui correspond à  un élément nommé
                <gi>TEI</gi>, l’élément racine de notre document. Son effet sera de produire un nouveau document XML, dont l'element racine sera nommé
                <gi>html</gi>, et qui contiendra deux autres elements: un 
<gi>head</gi> et un  <gi>body</gi>. <!--Nous precisons d'ailleurs que le format de ce nouveau document sera HTML. --></item><item><hi>Attention aux espaces de noms!</hi> Nous n'avons pas explicité qu'il s'agit d'un <q>TEI</q> de l'espace de noms de la TEI -- mais nous avons précisé que ce dernier sera l'espace de noms par défaut, donc cela ne pose aucune problème.</item><item>
               Dans le <gi>head</gi>, on met des metadonnees concernant le document HTML (cela correspond en quelque sorte au <gi>teiHeader</gi>); en l'occurrence nous fournissons par defaut un element <gi>meta</gi> pour assurer l'affichage correct des caractères Unicode. Dans le <gi>body</gi> on va mettre le contenu de notre document, en appliquant la commande 
                  <gi>xsl:apply-templates</gi></item>
              <item>Ce dernier va essayer d’appliquer tous les templates disponibles… il n’y en a
                pas, donc il ne va produire que le texte du document. </item>
              <item>… et en effet, si vous revenez sur votre navigateur et regardez la source HTML du
                fichier, c’est ce qu’il a fait.</item>
            </list></p>

          <p>Au travail ! D’abord, nous allons extraire de l’en-tête un titre pour le document HTML,
            et supprimer le reste du TEI Header.</p>

          <list>
              <item>Ajoutez un element <gi>title</gi> à l’intérieur de l’élément <gi>head</gi>, juste après la fin du <gi>meta</gi>. 
              Pour trouver le titre du document il faut naviguer de la racine du document source (l’élément TEI) jusqu’à
              l’élément <gi>title</gi>, qui se trouve dans le <gi>titleStmt</gi>, dans le
                <gi>fileDesc</gi>, dans le <gi>teiHeader</gi>. Cela s’effectue avec un
                <term>XPath</term>, bien-sur ! </item>
            <item>Tapez <code>&lt;xsl:value-of
                select="teiHeader/fileDesc/titleStmt/title"/&gt;</code>.</item>
            <item>Modifiez la balise <gi>xsl:apply-templates</gi>, en ajoutant <code>
                select="text"</code> </item>
            <item>Cliquez sur le bouton Indentation. Votre feuille de style maintenant devrait
              ressembler à ceci :</item>
          </list>
          <p><graphic height="8cm" url="images/script-1.png"/></p>
          <list>
            <item>Cliquez sur l’icône de la disquette (ou tapez ctrl-s) pour enregistrer les
              modifications que vous venez de faire.</item>
            <item>Cliquez sur l’onglet <ident>duBellay.xml</ident> pour revenir sur votre document
              XML.</item>
            <item>Cliquez sur l’icône triangle-rouge pour relancer la transformation (ou tapez
              CTRL-maj-T)</item>
            <item>Voyons ce que cela donne : cette fois, on ne voit que le <gi>text</gi> de notre
              document. On fait des progrès !</item>
          </list>

          <p>Maintenant, on va ajouter des templates.</p>

          <list>
            <item>Revenez sur la feuille de style. </item>
            <item>Ajoutez </item>
            <item><list>
                <item>un template pour <gi>l</gi>, qui va ajouter une balise <code>&lt;br/></code> après
                  chaque vers</item>
              <item>un template pour <gi>lb</gi>, qui va ajouter une balise <code>&lt;br/></code> à chaque
                  saut de ligne</item>
                <item>un template pour <gi>head</gi>, qui va l’entourer de <gi>h2</gi>
                </item>
                <item>un template pour <gi>lg</gi>, qui va l’entourer de <gi>p</gi>, et en plus le
                  préfixer du numéro de chaque strophe.</item>
              </list></item>
            <item>Voici les templates requis… essayez de comprendre par vous-même le fonctionnement
              de chacun d’entre eux. </item>
          </list>
          <p><graphic height="8cm" url="images/script-2.png"/>
          </p>
        </div>
        <!--
<div><head>Stylage</head>

        <p> Le code HTML, c’est la XSLT qui l’a généré (en plus de
          XSLT, il faut donc connaître au moins un peu TEI et HTML pour écrire un programme XSLT qui génère une page Web à partir d’un fichier TEI).
          La mise en forme est réalisée grâce à une feuille de style CSS très sommaire qui est dans
          le dossier et qui s’appelle <ident>acteRoyal.css</ident>. CSS (Cascading Style Sheets) est
          une norme du W3C (encore une), qui définit un langage pour contrôler la présentation des
          pages Web. Les instructions de mise en forme CSS peuvent être embarquées dans le fichier
          HTML, ou être réunies dans un fichier <ident>*.css</ident>. Aujourd’hui une bonne pratique
          de développement Web consiste à externaliser les instructions de mise en forme : c’est
          plus facile à maintenir, à modifier, c’est réutilisable, le Web design peut être confié à
          un… Web designer tandis que quelqu’un d’autre va s’occuper du code HTML, la séparation
          de la structure et de la mise en forme est claire. </p>
</div>
-->
        <div>
          <head>Traitement des <gi>choice</gi></head>
          <p>Est-ce que le XSLT peut nous aider à mieux traiter ces éléments <gi>choice</gi>? Bien
            sur, oui. D’abord, on pourrait simplement ajouter un template qui va supprimer les
              <gi>orig</gi> (ou les <gi>reg</gi> si vous le préfériez).</p>
          <p>Tout ce qu’il faut, c’est ajouter un template comme ceci : <code>&lt;xsl:template
              match="orig"/></code>. Essayez-le. Est-ce que vous comprenez comment cela fonctionne ?
            Si oui, vous avez bien compris les principes de XSLT !</p>

        </div>
        <div>
          <head>Pour aller plus loin…</head>
          
          
             
          <list>
            <item>Créez un paramètre <ident>modernisation</ident> avec <gi>xsl:param</gi>, avec
              comme valeur "oui" ou "non", selon votre préférence. <!--(Attention de ne pas introduire
              des blancs autour du mot !).--> Ceci va contrôler la suppression ou bien des
              <gi>reg</gi>, ou bien des <gi>orig</gi> selon la valeur qu’on lui donne. Par exemple,
              s’il aura la valeur <code>oui</code> on supprimera les <gi>orig</gi>. </item>
            <item>Ajoutez un template pour l’élément <gi>choice</gi>, qui contiendra un
                <gi>xsl:choose</gi> pour tester la valeur de ce paramètre </item>
            <item>Ensuite modifiez votre feuille de style pour entourer en guillemets la partie du <gi>choice</gi> affichee, pour signaler qu'il y a eu une modification de la source:   Les experts en HTML peuvent proposer d’autre modes d'affichage éventuels pour les
                <gi>choice</gi>, sous contrôle d’autres valeurs du paramètre… </item>
          </list>
          <p>Afficher l’image du facsimilé (<code>pb/@facs</code>) de l’original avant la transcription</p>
          <p>Qu’est-ce qu’on ferait pour n’afficher qu’une partie du texte? Modifiez votre feuille
            de style pour n’afficher que le vers initial de chaque strophe. <!--Ensuite, vous pourriez
            les trier par ordre alphabétique….--></p>
           

          <p>Vous trouverez dans le fichier <ident>duBellayCorr.xsl</ident> une version corrigée de
            cet exercice… ne le regardez pas tout de suite !</p>

        </div>

      </div>

    </body>
  </text>
</TEI>
