<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>Initiation à XPath et XSLT (1) </title>
        <title>
          <lb/>Esquisse d’une initiation aux normes de transformation XML</title>
        <author>Lou Burnard Consulting</author>
        <author>Alexei Lavrentiev</author>
      </titleStmt>
      <editionStmt>
        <edition>
          <date>2022 révision pour ETiPAS</date>
        </edition>
      </editionStmt>
      <publicationStmt>
        <publisher>Lou Burnard Consulting</publisher>
        <availability>
          <p>Freely available for use and derivative works under a Creative Commons Attribution
            license.</p>
        </availability>
      </publicationStmt>
      <sourceDesc>
        <p>Original talk by Lou Burnard edited and adapted in 2017 by Alexei Lavrentiev</p>
        <p>Translated and adapted from Rahtz 2009-07-23; previous talks, TEI Gudeidelines, etc.</p>
      </sourceDesc>
    </fileDesc>
    <revisionDesc>
      <change>
        <date>$LastChangedDate: 2022-05-31</date>
        <name>$LastChangedBy: Lou</name>
        <note>$LastChangedRevision: 2$</note>
      </change>
    </revisionDesc>
  </teiHeader>
  <text>
    <body>

      <div type="slide" rend="slide">
        <head>Objectifs</head>
        <p rend="box">Ceci n’est pas une formation complète! son objectif est de ... </p>
        <list>
          <item>vous donner un avant-goût des possibilités offertes par les normes XSLT et
            XPath</item>
          <item>surtout dans le domaine de traitement des documents <q>XML-TEI</q>, principalement
            donc issus des sciences humaines</item>
          <item>aborder les concepts fondamentaux et les usages les plus répandus de la norme
            XSLT</item>
          <!--item>vous préparer pour une formation plus approfondie </item-->
        </list>
      </div>

      <div type="slide" rend="slide">
        <head>XSL: un ensemble de normes complémentaires</head>
        <p>
          <list type="unordered">
            <item>XPath: une syntaxe normalisée pour définir et accéder aux sous-parties d’une
              arborescence XML </item>
            <item>XSLT: une norme informatique pour la transformation des arborescences XML </item>
            <item>XSL FO: un vocabulaire XML pour la description d’affichage des pages </item>
          </list>
        </p>
        <p>Tous les trois développés et maintenus par le W3C, comme la norme XML.</p>
      </div>


      <div>
        <head>A quoi sert XSL ?</head>
        <list>
          <item>Un document XML n’est qu’une chaîne de caractères Unicode avec des balises: pourquoi
            pas le traîter en tant que tel?</item>
          <item>Parce que les balises encodent quelque chose de signifiant, a distinguer des chaînes
            de caractères contenus.</item>
          <item>(et aussi parce que la syntaxe XML permet de variation ...
            <!--<egXML xmlns="http://www.tei-c.org/ns/Examples"><![CDATA[
<foo       bar= "x" baz = "z"></foo>
<foo
baz= "z" bar = 
"x"/>]]>
</egXML>-->
          </item>
        </list>
        <p><graphic width="75%" url="../Graphics/xml-as-text.png"/></p>
        <list>
          <item>Un document XML sert a représenter une structure, une arborescence. La
              <emph>structuration</emph> d’un document XML fait partie de sa signification.</item>
        </list>
        <p rend="box">Nous souhaitons traiter la signification du document, et non pas son
          apparence!</p>
      </div>


      <div type="slide" rend="slide">
        <head>C’est quoi une arborescence ?</head>
        <p><graphic height="50%" url="../Graphics/arborescence.png"/></p>
        <list>
          <item>un ensemble de <term>nœuds</term>, organisé de manière hiérarchique</item>
          <item>chaque nœud porte un <term>identifiant générique</term> (son "type")</item>
          <item>il y a un seul <term>nœud racine</term> qui contient (ou domine) tous les
            autres</item>
          <item>chaque nœud peut contenir (ou dominer) <list>
              <item>une sous-arborescence</item>
              <item>ou un morceau de texte</item>
              <!--item>facultativement un ensemble d’<term>attributs</term></item-->
            </list></item>
          <!--item>chaque attribut comporte un <term>nom</term> et un <term>valeur</term> </item-->
        </list>
      </div>

      <div type="slide" rend="slide">
        <head>Arborescence XML</head>
        <list>
          <item>chaque nœud correspond à un élément identifié</item>
          <item>les <term>attributs</term> d’un élément constituent une sous-arborescence associée
            au nœud</item>
          <item>chaque attribut comporte un <term>nom</term> et une <term>valeur</term>
          </item>
        </list>
      </div>

      <div type="slide" rend="slide">
        <head>Exemple texte XML ... </head>
        <egXML xmlns="http://www.tei-c.org/ns/Examples">
          <body type="anthology">
            <div type="poem">
              <head>Le faune</head>
              <lg type="stanza">
                <l n="1">Un vieux faune de terre cuite</l>
                <l n="2">Rit au centre des boulingrins,</l>
                <l n="3">Présageant sans doute une suite</l>
                <l n="4">Mauvaise à ces instants sereins</l>
              </lg>
              <lg type="stanza">
                <l n="5">Qui m'ont conduit et t'ont conduite,</l>
                <l n="6">- Mélancoliques pèlerins, -</l>
                <l n="7">Jusqu'à cette heure dont la fuite</l>
                <l n="8">Tournoie au son des tambourins.</l>
              </lg>
            </div>
            <div type="shortpoem">
              <head>Colloque sentimental</head>
              <lg type="couplet">
                <l n="1">Dans le vieux parc solitaire et glacé.</l>
                <l n="2">Deux formes ont tout à l'heure passé.</l>
              </lg>
            </div>
          </body>
        </egXML>
        <!--figure><graphic url="xpath-eg-0.png"/></figure-->
      </div>
      <div type="slide" rend="slide">
        <head>.. ou, en forme d’arborescence: </head>
        <figure>
          <graphic url="../Graphics/xpath-eg-1.png"/>
        </figure>
      </div>


      <div type="slide" rend="slide">
        <head>XPath : une feuille de route</head>
        <p>Pour accéder aux composants d’un document XML, on spécifie un <term>chemin</term>,
          spécifiant les nœuds de l'arborescence qu’il faut traverser pour arriver à la partie
          souhaitée</p>
        <p>Par exemple, pour arriver aux <gi>head</gi>s dans cet exemple, on commence au
            <gi>body</gi>, puis passe à un <gi>div</gi> fils, et ensuite on arrive à un
            <gi>head</gi> fils </p>
        <p>En XPath, on pourrait dire : <code>/body/div/head</code></p>
      </div>

      <div type="slide" rend="slide">
        <head>Astuce!</head>
        <p>oXygen vous permet tout simplement de visualiser l'effet d'un XPath...</p>
        <list>
          <item>Ouvrez le fichier <ident>verlaine.xml</ident> dans oXygen</item>
          <item>En haut a gauche il y a un champ avec le label XPath2.0</item>
          <item>Vous pouvez taper une expression XPath ici, et en voir l'effet </item>
        </list>
        <figure>
          <graphic url="images/xpathWindow.png"/>
        </figure>
        <p>Essayons cela! Tapez <code>/body/div/head</code> dans le champ indique, et (s'il n y a
          pas de rouge) tapez Retour</p>
      </div>
      <div type="slide" rend="slide">
        <head/>
        <figure>
          <graphic url="images/xpath-1.png"/>
        </figure>
      </div>
      <div type="slide" rend="slide">
        <head/>
        <p>Et si on souhaitait sélectionner les <gi>lg</gi> au lieu des <gi>head</gi> ? </p>
        <p>Modifiez votre chemin en changeant <code>head</code> en <code>lg</code>, et ça donne ?
        </p>
      </div>
      <div type="slide" rend="slide">
        <head/>
        <figure>
          <graphic url="images/xpath-2.png"/>
        </figure>
      </div>
      <!--  <div type="slide" rend="slide">
        <head></head>
        <figure>
          <graphic url="../Graphics/xpath-eg-06.png"/>
        </figure>
      </div>
      <div type="slide" rend="slide">
        <head/>
        <figure>
          <graphic url="../Graphics/xpath-eg-07.png"/>
        </figure>
      </div>
      <div type="slide" rend="slide">
        <head/>
        <figure>
          <graphic url="../Graphics/xpath-eg-08.png"/>
        </figure>
      </div>-->


      <div type="slide" rend="slide">
        <head>Les étapes</head>
        <list>
          <item>Chaque étape sur le chemin represente un ensemble de <term>nœuds</term> qu'il faut trouver a ce point</item><item>A la fin du chemin, le résultat du parcours sera le dernier ensemble de noeuds</item>
          <item>Un nœud peut être : <list>
            <item>un élément : <code>nom-d-élément</code> ou <code>*</code></item>
            <item>un attribut : <code>@nom-d-attribut</code> ou <code>@*</code></item>
              <item>un morceau de texte : <code>text()</code></item>
              <item>un commentaire : <code>comment()</code></item>
              <item>une instruction de traitement : <code>processing-instruction()</code></item>
            </list>
          </item>
        </list>
      </div>
      <div type="slide" rend="slide">
        <head>Un attribut, par exemple</head>
        <list>
          <item>Modifiez encore votre XPath, en ajoutant <code>/@type</code> a la fin, après
              <code>lg</code></item>
          <item>L’arobas peut aussi être écrit a la longue comme <code>attribute::</code> si vous le
            préfériez</item>
        </list>
      </div>
      <div type="slide" rend="slide">
        <head/>
        <figure>
          <graphic url="images/xpath-3.png"/>
        </figure>
      </div>


      <div type="slide" rend="slide">
        <head>Plus formellement... </head>
        <list>
          <item><p>Chaque étape d'un chemin XPath s'exprime ainsi :
              <code>axe::nœud[prédicat]</code></p></item>
          <item>
            <p>par exemple: <code>child::div[contains(head, 'faun')] </code></p></item>
          <item>
            <p>Le résultat d'un parcours xPath est le dernier nœud du chemin. Dans notre exemple: un
                <gi>div</gi> qui contient un <gi>head</gi> contenant le text <q>faun</q></p></item>
          <item><p>Attention: un prédicat n'est pas une étape ... il faut bien distinguer
                <code>div[head]</code> (<gi>div</gi> contenant un <gi>head</gi>) de
                <code>div/head</code> (<gi>head</gi> contenu par un <gi>div</gi>)!</p></item>
        </list>
      </div>

      <!-- <div type="slide" rend="slide">
        <head/>
        <figure>
          <graphic url="../Graphics/xpath-eg-09.png"/>
        </figure>
      </div>
      <div type="slide" rend="slide">
        <head/>
        <figure>
          <graphic url="../Graphics/xpath-eg-10.png"/>
        </figure>
      </div>
  -->
      <!-- text() example needed -->

      <div type="slide" rend="slide">
        <head>Un prédicat sert a quoi?</head>
        <p>Un prédicat exprime une sélection parmi les nœuds trouves par une étape du chemin</p>
        <list>
          <item>On l’écrit entre crochets [ et ] </item>
          <item>Une restriction peut concerner : <list>
              <item>la valeur d’un attribut</item>
              <item>ou la position ordinale du nœud dans l’arbre</item>
              <item>ou l’existence d’un élément du type indiqué</item>
            </list></item>
          <item>et elle peut utiliser des <term>fonctions</term> prédéfinies</item>
        </list>
      </div>

      <!--  <div type="slide" rend="slide">
        <head/>
        <figure>
          <graphic url="../Graphics/xpath-eg-12.png"/>
        </figure>
      </div>-->
      <div type="slide" rend="slide">
        <head>Par exemple</head>
        <p>Nous souhaitons voir que les couplet. </p>


        <list>
          <item>Modifiez encore votre XPath, en remplaçant <code>/@type</code> à la fin par
              <code>[@type='couplet']</code>, après <code>lg</code></item>
        </list>
      </div>
      <div type="slide" rend="slide">
        <head/>
        <figure>
          <graphic url="images/xpath-4.png"/>
        </figure>
      </div>



      <div>
        <head>Sélection par position</head>
        <list>
          <item>Chaque nœud a une position parmi ses frères, accessible par l'expression
              <code>position()</code>, ou simplement par une chiffre</item>
          <item>Il y a aussi une expression <code>last()</code> permettant de retrouver le
            benjamin</item>
        </list>
        <p>Essayons l'expression <code>/body/div/lg/l[4]</code> par exemple... </p>
      </div>

      <div type="slide" rend="slide">
        <head/>
        <figure>
          <graphic url="images/xpath-5.png"/>
        </figure>
      </div>
      <div type="slide" rend="slide">
        <head/>
        <p>En effet, cet usage est une abréviation de la forme plus complète:
            <code>/body/div/lg/l[position()=4]</code></p>
        <p>Pour retrouver le dernier vers de chaque strophe, il faut écrire cela a la
            longue:<code>/body/div/lg/l[position()=last()]</code>
        </p>
      </div>


      <div type="slide" rend="slide">
        <head/>
        <figure>
          <graphic url="images/xpath-6.png"/>
        </figure>
      </div>

      <div>
        <head>Sélection par valeur d'attribut</head>
        <p>On peut comparer la valeur d'un attribut avec une valeur quelconque en utilisant les
          opérateurs = &lt; &gt; etc.</p>
        <p>Pour retrouver tous les <gi>l</gi> dont l'attribut <att>n</att> a une valeur inférieure a
          3, essayons l'XPath suivant: <code>/body/div/lg/l[@n &lt; 1]</code>
        </p>
      </div>

      <div type="slide" rend="slide">
        <head/>
        <figure>
          <graphic url="images/xpath-11.png"/>
        </figure>
      </div>


      <div>
        <head>Sélection par contenu</head>
        <p>Si on souhaite sélectionner selon le contenu d'un élément, on peut designer le contenu
          d'un nœud en utilisant un point (.) et ensuite faire une comparaison en utilisant une des
          fonctions suivantes: <list>
            <item><code>contains(x,y)</code> : est-ce que la chaîne y apparaît quelque part dans la
              chaîne x ?</item>
            <item><code>substring-before(x,y)</code> : retourne la sous-chaine de x précédant la
              chaîne y (si possible)</item>
            <item><code>substring-after(x,y)</code> : retourne la sous-chaine de x suivant la chaîne
              y (si possible)</item>
          </list></p>
        <p>Par exemple: on veut tous les lignes content le mot <q>vieux</q>? Essayons l'XPath
            <code>/body/div/lg/l[contains(., 'vieux')]</code></p>
      </div>

      <div type="slide" rend="slide">
        <head/>
        <figure>
          <graphic url="images/xpath-12.png"/>
        </figure>
      </div>


      <div type="slide" rend="slide">
        <head>Direction de marche</head>
        <p>On n'est pas obligé de voyager toujours de haut en bas, de père en fils, en utilisant une
          seul étape. Plusieurs <term>axes</term> sont définies, par exemple: </p>
        <list>
          <item><term>child::</term> on descend une fois dans l'hiérarchie (forme abrégé: <code/>
            i.e. c'est l'axe a suivre par défaut de spécification au contraire)</item>
          <item><term>descendant::</term> on descend autant que nécessaire dans l'hiérarchie (forme
            abrégé: <code>//</code>)</item>
          <item><term>parent::</term> on monte une fois dans l'hiérarchie (forme abrégé:
              <code>..</code>)</item>
          <item><term>ancestor::</term> on monte autant que nécessaire dans l'hiérarchie</item>
          <item><term>preceding-sibling::</term> on cherche un élément frère (avec le même
            parent)</item>
          <item><term>preceding::</term> on cherche un élément frère (de n'importe quel
            parent)</item>
          <item>et pareillement pour <term>following::</term> et
            <term>following-sibling::</term></item>
        </list>
      </div>
      <div type="slide" rend="slide">
        <head>Le point de départ</head>
        <p>Le point de départ d'un XPath, autrement dit son contexte, peut être n’importe quel point
          dans l’arborescence. Ensuite, à chaque étape, on peut spécifier l'axe à suivre pour
          continuer. </p>
        <!--<p>Les noms de quelques axes peuvent etre abrégés: <list>
            <item><code>//</code> signifie <q>descendant::</q></item>
            <item><code>..</code> signifie <q>parent::</q></item>
            <item>et <code/> (aucune indication d'axe) signifie <q>child::</q></item>
          </list>-->
        <!--</p>-->
        <p>Sont donc équivalentes les manières suivantes de retrouver tous les vers d'un poème:</p>
        <list>
          <item><code>/child::body/child::div</code>
            <code>[attribute::type='poem']/descendant::l</code></item>
          <item><code>/body/div[@type='poem']//l</code></item>
          <item><code>//div[@type='poem']//l</code></item>
        </list>
        <p>Quel est la différence entre cette dernière, et la suivante: <code>//l</code> ?</p>
      </div>
      <div type="slide" rend="slide">
        <head/>
        <figure>
          <graphic url="images/xpath-7.png"/>
        </figure>
        <cb/>
        <figure>
          <graphic url="images/xpath-8.png"/>
        </figure>
      </div>

      <div type="slide" rend="slide">
        <head>Exemple de navigation</head>
        <p>En partant d'un <gi>lg</gi> n'importe ou, on cherche les valeurs des attributs
            <att>type</att> de son parent?</p>
        <p>Essayons <code>//lg../@type</code></p>
      </div>

      <div type="slide" rend="slide">
        <head/>
        <figure>
          <graphic url="images/xpath-9.png"/>
        </figure>
      </div>

      <div type="slide" rend="slide">
        <head>Fonctions XPath</head>
        <p>XPath fournit  une large librairie de fonctions utiles. On signale ici seulement
          quelques-unes pas encore rencontrés: <list>
            <item><code>count(x)</code> fournit le nombre des nœuds dans l’arbre x</item>
            <!-- <item><code>position()</code> fournit le nombre ordinal du nœud courant par rapport à
              son contexte</item>
            <item><code>last()</code> fournit le nombre ordinal du dernier nœud courant par rapport
              à son contexte</item>-->
            <item><code>contains(x,y)</code> teste l’existence de la chaîne <code>y</code> dans le
              morceau de texte <code>x</code>
            </item>
            <item><code>replace(x,r,s)</code> retourne une révision de la chaîne x, dans laquelle
              chaque occurrence des caractères indiques par le regexp r est remplace par la chaîne s </item>
            <item><code>tokenize(x, r)</code> retourne une séquence des sous-chaînes de s, utilisant
              le regexp r pour les découper</item>
            <item><code>normalise-space(x)</code>retourne une révision de la chaîne x, dans laquelle
              chaque séquence de <term>whitespace</term> est remplace par un seul blanc</item>
            <item><code>distinct-values(s)</code> retourne une séquence des valeurs uniques trouves
              dans la séquence s</item>
          </list>
        </p>
        <p>On peut enchaîner ces fonctions comme nécessaire. Par exemple, quel est l'effet de
          l'XPath <code>count(distinct-values(tokenize(normalize-space(replace(/body,'[.,-]','
            ')))))</code>?</p>
      </div>
      <!-- les 52 mots distincts du document-->

      <div type="slide" rend="slide">
        <head>Premier exercice</head>
        <p>Tester votre compréhension de XPath! D'abord, ouvrez le fichier
            <ident>duBellay.xml</ident>. Essayez ensuite de trouver une reponse XPath pour chacun de
          cette petite liste de requêtes : <list type="ordered">
            <item>quel est l’élément racine du document XML ?</item>
            <item>quel est le titre donné à ce document ?</item>
            <item>qui est le responsable de la création du fichier ?</item>
            <item>quelle est l’origine de la version encodée ?</item>
            <item>quelle est la date de la révision la plus récente du document ?</item>
            <item>combien y a-t-il de strophes (<gi>lg</gi>) dans le sonnet ?</item>
            <item>combien y a-t-il de segments de texte dont la graphie est considérée incorrecte
                (<gi>orig</gi>) aujourd’hui ?</item>
            <item>combien y a-t-il de vers (<gi>l</gi>) qui contiennent au moins un tel
              segment ?</item>
            <item>quel est le contenu textuel du premier vers de chaque strophe ? et du dernier? </item>
            <item>quels nœuds texte contiennent la chaîne de caractères "jamais"</item>
          </list></p>
        <p>Vous trouverez des réponses dans le document tutoriel: mais essayew de ne pas le regarder
          tout de suite!</p>
      </div>
    </body>
  </text>
</TEI>
